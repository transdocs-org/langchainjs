# 不安全的缓存算法

> **警告：不安全的缓存键算法（SHA-1）**

LangChain 默认的缓存键编码器使用 SHA-1 哈希算法为 prompt/LLM 对生成缓存键。虽然这在大多数缓存场景中是可以接受的，但 **SHA-1 并 _不_ 具备抗碰撞能力**。这意味着攻击者有可能精心构造两个不同的输入，使其生成相同的缓存键，从而导致潜在的缓存污染或意外的缓存命中。

现在，SHA-1 在 LangChain 中已不推荐用于缓存键生成。然而为了保持与现有部署的兼容性，从 SHA-1 迁移是可选的而不是自动进行的。在未来的版本中，SHA-1 将被更安全的哈希算法取代，成为默认选项。

### 为什么这很重要？

- **安全风险：** 如果你的应用暴露给不可信的输入，攻击者可以有意生成两个不同的 prompt 或 LLM 键，使它们哈希到相同的值，导致一个覆盖另一个的缓存条目。
- **数据完整性：** 哈希碰撞可能导致缓存返回错误的生成内容，在敏感或高完整性环境中可能会带来问题。

### 何时需要关注？

- 如果你的应用面向公众或处理敏感数据。
- 如果缓存完整性对你的工作流程至关重要。
- 如果你的合规性或安全要求禁止使用弱哈希函数。

### 如何缓解？

你可以通过在缓存实例上使用 `makeDefaultKeyEncoder()` 方法提供一个更强的哈希函数（例如 SHA-256 或 SHA-3）来进行缓存键编码。例如：

```ts
import { sha256 } from "@langchain/core/utils/hash/sha256";

const client = new CacheClient(...);
client.makeDefaultKeyEncoder(sha256);
```