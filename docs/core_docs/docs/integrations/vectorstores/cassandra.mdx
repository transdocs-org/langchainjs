---
sidebar_class_name: node-only
---

# Cassandra

:::tip 兼容性
仅适用于 Node.js。
:::

[Apache Cassandra®](https://cassandra.apache.org/_/index.html) 是一个 NoSQL、面向行、高度可扩展且高可用的数据库。

[最新版本](<https://cwiki.apache.org/confluence/display/CASSANDRA/CEP-30%3A+Approximate+Nearest+Neighbor(ANN)+Vector+Search+via+Storage-Attached+Indexes>) 的 Apache Cassandra 原生支持向量相似性搜索。

## 安装配置

首先安装 Cassandra Node.js 驱动：

import IntegrationInstallTooltip from "@mdx_components/integration_install_tooltip.mdx";

<IntegrationInstallTooltip></IntegrationInstallTooltip>

```bash npm2yarn
npm install cassandra-driver @langchain/community @langchain/openai @langchain/core
```

根据你的数据库提供商，连接数据库的具体方式会有所不同。我们将创建一个名为 `configConnection` 的文档，该文档将作为向量存储配置的一部分使用。

### Apache Cassandra®

向量搜索在 [Apache Cassandra® 5.0](https://cassandra.apache.org/_/Apache-Cassandra-5.0-Moving-Toward-an-AI-Driven-Future.html) 及以上版本中支持。你可以使用标准的连接文档，例如：

```typescript
const configConnection = {
  contactPoints: ['h1', 'h2'],
  localDataCenter: 'datacenter1',
  credentials: {
    username: <...> as string,
    password: <...> as string,
  },
};
```

### Astra DB

Astra DB 是一个云原生的 Cassandra-as-a-Service 平台。

1. 创建一个 [Astra DB 账户](https://astra.datastax.com/register)。
2. 创建一个[启用向量功能的数据库](https://astra.datastax.com/createDatabase)。
3. 为你的数据库创建一个[token](https://docs.datastax.com/en/astra/docs/manage-application-tokens.html)。

```typescript
const configConnection = {
  serviceProviderArgs: {
    astra: {
      token: <...> as string,
      endpoint: <...> as string,
    },
  },
};
```

你也可以使用 `datacenterID:` 属性代替 `endpoint:`，并且可以附加 `regionName:` 属性。

## 文档索引

```typescript
import { CassandraStore } from "langchain/vectorstores/cassandra";
import { OpenAIEmbeddings } from "@langchain/openai";

// 上面已定义 configConnection 文档
const config = {
  ...configConnection,
  keyspace: "test",
  dimensions: 1536,
  table: "test",
  indices: [{ name: "name", value: "(name)" }],
  primaryKey: {
    name: "id",
    type: "int",
  },
  metadataColumns: [
    {
      name: "name",
      type: "text",
    },
  ],
};

const vectorStore = await CassandraStore.fromTexts(
  ["I am blue", "Green yellow purple", "Hello there hello"],
  [
    { id: 2, name: "2" },
    { id: 1, name: "1" },
    { id: 3, name: "3" },
  ],
  new OpenAIEmbeddings(),
  cassandraConfig
);
```

## 查询文档

```typescript
const results = await vectorStore.similaritySearch("Green yellow purple", 1);
```

或者带过滤条件的查询：

```typescript
const results = await vectorStore.similaritySearch("B", 1, { name: "Bubba" });
```

## 向量类型

Cassandra 支持 `cosine`（默认）、`dot_product` 和 `euclidean` 相似性搜索；这在向量存储首次创建时定义，并在构造函数参数 `vectorType` 中指定，例如：

```typescript
  ...,
  vectorType: "dot_product",
  ...
```

## 索引

随着 5.0 版本的发布，Cassandra 引入了存储附加索引（SAI）。这些索引允许在不指定分区键的情况下进行 `WHERE` 过滤，并支持非等值等其他操作符类型。你可以使用 `indices` 参数来定义这些索引，该参数接受零个或多个包含 `name` 和 `value` 的字典。

索引是可选的，但如果对非分区列使用过滤查询，则必须定义索引。

- `name` 字段是对象名称的一部分；在一个名为 `test_table` 的表上，一个 `name: "some_column"` 的索引将命名为 `idx_test_table_some_column`。
- `value` 字段是创建索引的列，需要用 `(` 和 `)` 括起来。以上面的 `some_column` 列为例，应指定为 `value: "(some_column)"`。
- 可选的 `options` 字段是一个映射，传递给 `CREATE CUSTOM INDEX` 语句中的 `WITH OPTIONS =` 子句。该映射中的具体条目取决于索引类型。

```typescript
  indices: [{ name: "some_column", value: "(some_column)" }],
```

## 高级过滤

默认情况下，过滤器使用等值 `=` 进行匹配。对于那些有 `indices` 条目的字段，你可以提供一个 `operator`，其值是索引支持的操作符字符串；在这种情况下，你可以指定一个或多个过滤器，可以是单个元素或列表（多个条件将用 `AND` 连接）。例如：

```typescript
   { name: "create_datetime", operator: ">", value: some_datetime_variable }
```

或者：

```typescript
[
  { userid: userid_variable },
  { name: "create_datetime", operator: ">", value: some_date_variable },
];
```

`value` 可以是单个值或数组。如果它不是一个数组，或者数组中只有一个元素，则生成的查询将是 `${name} ${operator} ?` 这种形式，`value` 将绑定到 `?`。

如果 `value` 数组中有多个元素，那么会计算 `name` 中未加引号的 `?` 数量，并从 `value` 的长度中减去这个数，然后在操作符的右侧放入相应数量的 `?`；如果有多个 `?`，它们将被包裹在 `(` 和 `)` 中，例如：`(?, ?, ?)`。

这种方式可以对操作符左侧的值进行绑定，这对某些函数非常有用；例如地理距离过滤：

```typescript
{
  name: "GEO_DISTANCE(coord, ?)",
  operator: "<",
  value: [new Float32Array([53.3730617,-6.3000515]), 10000],
},
```

## 数据分区与复合键

在某些系统中，你可能出于各种原因（例如按用户或按会话）希望对数据进行分区。Cassandra 中的数据总是被分区的；默认情况下，该库将按主键的第一个字段进行分区。你可以指定多个字段组成记录的主键（唯一键），并可选地指示哪些字段应成为分区键的一部分。例如，向量存储可以同时按 `userid` 和 `collectionid` 分区，附加字段 `docid` 和 `docpart` 用于标识单个条目：

```typescript
  ...,
  primaryKey: [
    {name: "userid", type: "text", partition: true},
    {name: "collectionid", type: "text", partition: true},
    {name: "docid", type: "text"},
    {name: "docpart", type: "int"},
  ],
  ...
```

在搜索时，你可以在过滤器中包含分区键而无需为这些列定义 `indices`；你不需要指定所有分区键，但必须指定主键中排在前面的那些键。在上面的例子中，你可以指定 `{userid: userid_variable}` 或 `{userid: userid_variable, collectionid: collectionid_variable}` 这样的过滤器，但如果你只想指定 `{collectionid: collectionid_variable}` 这样的过滤器，则必须将 `collectionid` 加入 `indices` 列表中。

## 额外配置选项

在配置文档中，还提供了更多可选参数；其默认值如下：

```typescript
  ...,
  maxConcurrency: 25,
  batchSize: 1,
  withClause: "",
  ...
```

| 参数             | 用途                                                                                                                                                                                                                      |
|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `maxConcurrency` | 同时发送到 Cassandra 的最大请求数。                                                                                                                                                                                       |
| `batchSize`      | 单个请求发送的文档数量。当使用大于 1 的值时，请确保你的批量大小不会超过 Cassandra 参数 `batch_size_fail_threshold_in_kb`。批次是未记录日志的。                                                                          |
| `withClause`     | Cassandra 表可以使用可选的 `WITH` 子句创建；这通常不需要，但为了完整性而提供。                                                                                                                                            |

## 相关内容

- 向量存储 [概念指南](/docs/concepts/#vectorstores)
- 向量存储 [操作指南](/docs/how_to/#vectorstores)